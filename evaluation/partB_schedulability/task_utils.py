#!/usr/bin/python2

# task_utils.py
# Generate tasksets with specific utilizations.

# Standard modules
import os
import sys
sys.dont_write_bytecode = True
import math
import shutil
import glob
import os
import re
import gc
import cgi
import random
import pickle
from copy import *

# Installed modules

# Local modules
from config import *

#
# Constants
#

#
# Global Variables
#

#
# Functions
#

# Generate a taskset for each core.
#
# This is a convenience function that returns a list of tasksets, each with the
# given utilization. There is one taskset for each core.
#
# param[in] core_u Desired taskset utilization per core (from 0 to 100)
#
# returns List with one taskset for each core.
#
def GenTasksetMulti(core_u):
    core_tasksets = []    
    for i in range(0, CONFIG_NUM_CORES):
        core_tasksets.append(GenTaskset(core_u, "core" + str(i)))
    return core_tasksets

# Generate a taskset with the specified taskset utilization.
#
# This is done by generating tasks until the resulting taskset has a utilization
# within TASKSET_UTIL_ERROR percent of the given taskset_u. As such, the 
# generated taskset may contain any number of tasks. Tasks are generated by
# randomly selecting an execution time from CONFIG_TASK_WCETS_SLOTS, and
# randomly selecting a period from CONFIG_TASK_PERIODS_SLOTS.
#
# The deadline of each task is randomly selected from [wcet_slots, period_slots].
# I.e. The tasks have constrained deadlines. The utilization of each task is
# calculated as = wcet_slots/period_slots, and the overall taskset utilization
# is calculated as = u1 + u2 + u3 + ...
#
# We task is given a string name to make it uniquely identifiable. The task
# names increase monotonically, and are prepended with str_id.
#
# param[in] taskset_u The desired taskset utilization (from 0 to 100)
# param[in] str_id    Unique identifier for the taskset
#
# returns List of tasks, with each task of the form:
#         (task name, wcet_slots, period_slots, deadline_slots).
#
def GenTaskset(taskset_u, str_id):

    taskset_u_error = (float(CONFIG_TASKSET_UTIL_ERROR)/100) * taskset_u    
    taskset_u_min   = taskset_u - taskset_u_error    
    taskset_u_max   = taskset_u + taskset_u_error

    my_taskset   = [] # my taskset so far
    my_taskset_u = 0  # my taskset utilization so far
    iters        = 0  # number of iterations
    task_id      = 0  # identifies each task

    # Continuously generate tasks.
    while True:
        wcet_slots     = random.choice(CONFIG_TASK_WCETS_SLOTS)        
        period_slots   = random.choice(CONFIG_TASK_PERIODS_SLOTS)
        deadline_slots = random.randint(wcet_slots, period_slots)

        # Calculate task utilization.
        # We divide by period slots to get utilization.
        # We would divide by deadline_slots to get density.        
        task_u = float(wcet_slots)/period_slots

        # If the task does not push the taskset utilization over
        # the upper limit, add the task to the taskset.
        if ((my_taskset_u + task_u) <= taskset_u_max):
            task_name = str_id + "_" + str(task_id)
            my_taskset.append((task_name, wcet_slots, period_slots, deadline_slots))
            my_taskset_u += task_u
            task_id += 1

            # Check if our utilization is within target window.
            if (my_taskset_u >= taskset_u_min):
                return my_taskset # taskset is complete
       
        iters += 1
        if (iters > CONFIG_TASKSET_MAX_ITERS):
            # It is difficult to hit the desired utilization.
            # Try starting over with new tasks.
            my_taskset   = []
            my_taskset_u = 0
            task_id = 0
            iters = 0 

    # Should never happen.
    return 

